### 🎉명언 관리 프로그램🎉
* 1 단계. "종료" 입력시 프로그램 종료 [구현 완료]

```
출력 요구
==명언 앱==
명령) 종료
```
```
풀이
while문 조건을 True로 설정해 무한정 반복문에서 if로 종료조건 설정
```

* 2 단계. "등록" 입력시 명언과 작가를 입력받음. 줄바꿈으로 구분 [구현 완료]
```
출력 요구
== 명언 앱 ==
명령) 등록
명언 : 현재를 사랑하라.
작가 : 작자미상
명령) 종료
```
```
풀이
명언과 작가의 입력을 받기 위해 Scanner 패키지 import
```

* 3 단계. 등록시 생성된 명언번호 노출 [구현 완료]
```
출력 요구
== 명언 앱 ==
명령) 등록
명언 : 현재를 사랑하라.
작가 : 작자미상
1번 명언이 등록되었습니다.
명령) 종료
```
```
풀이
id 변수를 선언해 순서 관리 및 노출
```

* 4 단계. 등록할때 마다 생성되는 명언번호가 증가 [구현 완료]
```
출력 요구
== 명언 앱 ==
명령) 등록
명언 : 현재를 사랑하라.
작가 : 작자미상
1번 명언이 등록되었습니다.
명령) 등록
명언 : 현재를 사랑하라.
작가 : 작자미상
2번 명언이 등록되었습니다.
명령) 종료
```
```
풀이
등록 명령이 이루어질때마다 id가 1씩 증가되도록 작성
```

* 5 단계. 목록 구현 [구현 완료], [클래스 분리 구현], [getter 사용]
```
출력 요구
명령) 목록
번호 / 작가 / 명언
----------------------
2 / 작자미상 / 과거에 집착하지 마라.
1 / 작자미상 / 현재를 사랑하라.
```
```
풀이
Arraylist를 사용해 등록을 통해 입력받은 명언, 작가, 그 당시의 번호를 저장
```

* 6 단계. 명언 삭제 기능 구현 (기존 명언들은 번호 유지) [구현 완료]
```
출력 요구
명령) 삭제?id=1
1번 명언이 삭제되었습니다.
명령) 종료
```
```
풀이
명령의 시작점에서 "삭제?" 를 인식해 삭제 메소드로 연결.
```

* 7 단계. 존재하지 않는 명언삭제에 대한 예외처리 [구현 완료]
```
출력 요구
명령) 삭제?id=1
1번 명언이 삭제되었습니다.
명령) 삭제?id=1
1번 명언은 존재하지 않습니다.
명령) 종료
```
```
삭제 메소드에서 해당 id가 존재하지 않는 경우를 if문으로 배제
```

* 8 단계. 명언 수정기능 [구현 완료], [setter 사용]
```
출력 요구
명령) 수정?id=3
3번 명언은 존재하지 않습니다.
명령) 수정?id=2
명언(기존) : 과거에 집착하지 마라.
명언 : 현재와 자신을 사랑하라.
작가(기존) : 작자미상
```
```
풀이
명령의 시작점에서 "수정?"을 인식해 수정 메소드로 연결
```

* 파일 생성을 통해 영속성
  * 각 명언은 개별파일로 db/wiseSaying 폴더에 저장
  * 각 명언 파일명언 {명언번호}.json
  * 가장 마지막에 생성된 명언 번호는 db/wiseSaying/lastId.txt 파일에 숫자로 저장

```
출력 요구
명령) 목록
번호 / 작가 / 명언
----------------------
2 / 작자미상 / 과거에 집착하지 마라.
1 / 작자미상 / 현재를 사랑하라.
명령) 종료

프로그램 다시 시작...

== 명언 앱 ==
명령) 목록
번호 / 작가 / 명언
----------------------
2 / 작자미상 / 과거에 집착하지 마라.
1 / 작자미상 / 현재를 사랑하라.
```

* 1.json
```
출력 요구
{
  "id": 1,
  "content": "명언 1",
  "author": "작가 1"
}
```

* 2.json
```
출력 요구
{
  "id": 1,
  "content": "명언 1",
  "author": "작가 1"
}
```



* data.json 빌드
```
출력 요구
명령) 빌드
data.json 파일의 내용이 갱신되었습니다.
명령) 종료
```

  * date.json 양식
```
출력 요구
[
  {
    "id": 1,
    "content": "명언 1",
    "author": "작가 1"
  },
  {
    "id": 2,
    "content": "명언 2",
    "author": "작가 2"
  }
]
```

 * Controller, Service, Repository 구조 도입

   * 스프링부트의 일반적인 구조 참고

 * 고객의 요청 처리 흐름

   * 컨트롤러 => 서비스 => 리포지터리 => 파일DB

 * 추천구조

   * com.llwiseSaying.WiseSayingController.java

     * 역할 : 고객의 명령을 입력받고 적절을 응답을 표현

     * 이 단계에서는 스캐너 사용가능

   * com.llwiseSaying.WiseSayingService.java

     * 역할 : 순수 비지니스 로직

     * 스캐너 사용금지, 출력 금지

   * com.llwiseSaying.WiseSayingRepository.java

     * 역할 : 데이터의 조회/수정/삭제/생성을 담당

     * 스캐너 사용금지, 출력 금지

   * com.llwiseSaying.WiseSaying.java

     * 역할 : 명언 객체(번호/명언내용/작가)

     * 이 파일은 컨트롤러, 서비스, 리포지터티 모두에서 사용가능